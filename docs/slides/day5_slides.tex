\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{hyperref}

% Theme - Import oppstar theme from beamer-template directory
% Add beamer-template directory to LaTeX search path
\makeatletter
\def\input@path{{./beamer-template/}}
\makeatother

% Now load the theme components
\usepackage{./beamer-template/beamercolorthemeoppstar}
\usepackage{./beamer-template/beamerfontthemeoppstar}
\usepackage{./beamer-template/beamerinnerthemeoppstar}
\usepackage{./beamer-template/beamerouterthemeoppstar}
\usepackage{./beamer-template/beamerthemeoppstar}

% Colors
\definecolor{codeblue}{RGB}{0,102,204}
\definecolor{codegray}{RGB}{128,128,128}
\definecolor{codegreen}{RGB}{0,128,0}
\definecolor{backcolour}{RGB}{245,245,245}

% Code listing style
\lstdefinestyle{cstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single
}

\lstset{style=cstyle}

% Title page info
\title{Day 5: Hardware Debugging and MicroBlaze-V Peripherals}
\subtitle{C Programming for Post-Silicon Validation Engineers}
\author{Yahwista Salomo}
\date{6-Day Intensive Bootcamp}
\institute{Post-Silicon Validation Training Program}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Welcome to Day 5!}
\begin{center}
\Large Real Hardware, Real Validation!
\end{center}

\begin{itemize}
    \item \textbf{Yesterday:} Cross-compilation and modular programming
    \item \textbf{Today's Mission:} Master hardware debugging and peripherals
    \item \textbf{Validation Focus:} Hardware-in-the-loop testing
    \item \textbf{Real Hardware:} MicroBlaze-V GPIO, ADC, timers, and more
    \item \textbf{Outcome:} Complete embedded validation system!
\end{itemize}

\vspace{0.5cm}
\begin{center}
\textit{"Hardware is hard, but debugging makes it manageable"} - Embedded Systems Wisdom
\end{center}
\end{frame}

\begin{frame}
\frametitle{Today's Learning Objectives}
By the end of Day 5, you will:

\begin{enumerate}
    \item Use advanced GDB techniques for embedded debugging
    \item Program MicroBlaze-V peripherals (GPIO, ADC, timers)
    \item Implement hardware-in-the-loop testing
    \item Create fault injection and detection systems
    \item Optimize code for real-time constraints
    \item Build comprehensive hardware validation suites
\end{enumerate}

\vspace{0.5cm}
\begin{alertblock}{Hardware Reality}
Today we validate real silicon with real constraints!
\end{alertblock}
\end{frame}

\begin{frame}
\frametitle{Advanced GDB for Embedded Systems}
\textbf{Embedded debugging challenges:}
\begin{itemize}
    \item No console output during execution
    \item Limited memory and storage
    \item Real-time timing constraints
    \item Hardware-dependent behavior
    \item Interrupt-driven programming
\end{itemize}

\vspace{0.5cm}
\textbf{Solutions:}
\begin{itemize}
    \item \textbf{printf debugging:} Via USB serial
    \item \textbf{LED indicators:} Visual debugging
    \item \textbf{Hardware debuggers:} SWD/JTAG interfaces
    \item \textbf{Logic analyzers:} Signal timing analysis
    \item \textbf{Oscilloscopes:} Analog signal debugging
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Printf Debugging on MicroBlaze-V}
\vspace{-0.3cm}
\begin{lstlisting}[language=C, basicstyle=\fontsize{6}{6}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include "peripherals.h"

// UARTlite registers for debugging output
#define UARTLITE_BASE    0x40600000
#define UARTLITE_TX_FIFO (UARTLITE_BASE + 0x04)
#define UARTLITE_STAT_REG (UARTLITE_BASE + 0x08)
#define UARTLITE_SR_TX_FIFO_FULL 0x08

void debug_putc(char c) {
    volatile uint32_t *tx_fifo = (volatile uint32_t *)UARTLITE_TX_FIFO;
    volatile uint32_t *status = (volatile uint32_t *)UARTLITE_STAT_REG;

    while (*status & UARTLITE_SR_TX_FIFO_FULL);
    *tx_fifo = c;
}

void debug_puts(const char *str) {
    while (*str) debug_putc(*str++);
}

int main() {
    debug_puts("MicroBlaze-V Validation System Starting...\r\n");

    int test_count = 0;
    while (1) {
        debug_puts("Running test cycle ");
        debug_putc('0' + (test_count % 10));
        debug_puts("\r\n");

        int result = run_validation_tests();
        debug_puts("Test result: ");
        debug_puts(result ? "PASS" : "FAIL");
        debug_puts("\r\n");

        // Simple delay loop
        for (volatile int i = 0; i < 5000000; i++);
        test_count++;
    }
}
\end{lstlisting}

\begin{center}
\tiny \textbf{Viewing output:} Connect to UARTlite via QEMU console or hardware UART
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{GPIO-Based Debug Indicators}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include "peripherals.h"

// MicroBlaze-V GPIO registers
#define GPIO_BASE        0x40000000
#define GPIO_DATA_REG    (GPIO_BASE + 0x00)
#define GPIO_TRI_REG     (GPIO_BASE + 0x04)

#define LED_PIN_MASK     0x01
#define DEBUG_PIN_1_MASK 0x02
#define DEBUG_PIN_2_MASK 0x04

void debug_gpio_init(void) {
    volatile uint32_t *gpio_tri = (volatile uint32_t *)GPIO_TRI_REG;
    // Set pins as outputs (0 = output, 1 = input)
    *gpio_tri &= ~(LED_PIN_MASK | DEBUG_PIN_1_MASK | DEBUG_PIN_2_MASK);
}

void debug_signal_test_start(void) {
    volatile uint32_t *gpio_data = (volatile uint32_t *)GPIO_DATA_REG;
    *gpio_data |= DEBUG_PIN_1_MASK;  // Set debug pin 1 high
}

void debug_signal_test_end(void) {
    volatile uint32_t *gpio_data = (volatile uint32_t *)GPIO_DATA_REG;
    *gpio_data &= ~DEBUG_PIN_1_MASK;  // Set debug pin 1 low
}

void debug_signal_error(void) {
    volatile uint32_t *gpio_data = (volatile uint32_t *)GPIO_DATA_REG;
    // Rapid blink pattern for errors
    for (int i = 0; i < 10; i++) {
        *gpio_data |= LED_PIN_MASK;   // LED on
        for (volatile int j = 0; j < 500000; j++);  // Delay
        *gpio_data &= ~LED_PIN_MASK;  // LED off
        for (volatile int j = 0; j < 500000; j++);  // Delay
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{MicroBlaze-V Peripheral Overview}

\begin{center}
\textbf{MicroBlaze-V FPGA Soft Processor Peripherals}
\end{center}

\begin{columns}[T]
\begin{column}{0.5\textwidth}
\textbf{Communication:}
\begin{itemize}
    \item \footnotesize UARTlite (Debug/Console)
    \item \footnotesize UART 16550 (Full-featured)
    \item \footnotesize AXI Ethernet (Network)
    \item \footnotesize AXI DMA (High-speed transfers)
\end{itemize}
\end{column}
\begin{column}{0.5\textwidth}
\textbf{Control \& Timing:}
\begin{itemize}
    \item \footnotesize GPIO (General Purpose I/O)*
    \item \footnotesize XPS Timer (Precision timing)
    \item \footnotesize AXI Timer (Advanced timing)
    \item \footnotesize Interrupt Controller (INTC)
\end{itemize}
\end{column}
\end{columns}

\vspace{0.5cm}
\textbf{Validation applications:}
\begin{itemize}
    \item \footnotesize \textbf{UARTlite:} Debug output, test result reporting
    \item \footnotesize \textbf{GPIO:} Digital signal testing, control interfaces*
    \item \footnotesize \textbf{Timers:} Precise timing measurements, timeouts
    \item \footnotesize \textbf{Ethernet:} Network protocol validation
    \item \footnotesize \textbf{DMA:} High-speed data transfer testing

\vspace{0.2cm}
\footnotesize \textbf{*Note:} GPIO is unimplemented in QEMU (stub device only)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{GPIO Advanced Programming - Part 1}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include <stdbool.h>
#include "peripherals.h"

#define GPIO_BASE        0x40000000
#define GPIO_DATA_REG    (GPIO_BASE + 0x00)
#define GPIO_TRI_REG     (GPIO_BASE + 0x04)

typedef struct {
    uint8_t pin_mask;
    bool input_test_pass;
    bool output_test_pass;
    bool tristate_test_pass;
} gpio_comprehensive_result_t;

int test_gpio_comprehensive(uint8_t pin_mask, gpio_comprehensive_result_t *result) {
    volatile uint32_t *gpio_data = (volatile uint32_t *)GPIO_DATA_REG;
    volatile uint32_t *gpio_tri = (volatile uint32_t *)GPIO_TRI_REG;

    result->pin_mask = pin_mask;

    // Test 1: Output functionality
    *gpio_tri &= ~pin_mask;  // Set as output (0 = output)
    *gpio_data |= pin_mask;  // Set high
    for (volatile int i = 0; i < 1000; i++);  // Delay
    bool high_output = (*gpio_data & pin_mask) != 0;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{GPIO Advanced Programming - Part 2}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
    *gpio_data &= ~pin_mask; // Set low
    for (volatile int i = 0; i < 1000; i++);  // Delay
    bool low_output = (*gpio_data & pin_mask) == 0;
    result->output_test_pass = high_output && low_output;

    // Test 2: Input functionality (tristate)
    *gpio_tri |= pin_mask;   // Set as input (1 = input)
    result->tristate_test_pass = true;  // Basic tristate test

    // Overall pass/fail
    return result->output_test_pass && result->tristate_test_pass;
}
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{Ethernet Controller Validation - Part 1}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include "peripherals.h"

// MicroBlaze-V Ethernet Lite registers
#define ETHLITE_BASE     0x40E00000
#define ETHLITE_TX_PING  (ETHLITE_BASE + 0x0000)
#define ETHLITE_MDIOADDR (ETHLITE_BASE + 0x07E4)
#define ETHLITE_MDIOWR   (ETHLITE_BASE + 0x07E8)
#define ETHLITE_MDIORD   (ETHLITE_BASE + 0x07EC)
#define ETHLITE_MDIOCTRL (ETHLITE_BASE + 0x07F0)

void ethernet_validation_init(void) {
    volatile uint32_t *mdio_ctrl = (volatile uint32_t *)ETHLITE_MDIOCTRL;

    // Enable MDIO interface
    *mdio_ctrl = 0x08;  // Enable MDIO

    uartlite_puts("Ethernet controller initialized\n");
}

int validate_phy_registers(void) {
    volatile uint32_t *mdio_addr = (volatile uint32_t *)ETHLITE_MDIOADDR;
    volatile uint32_t *mdio_ctrl = (volatile uint32_t *)ETHLITE_MDIOCTRL;
    volatile uint32_t *mdio_rd = (volatile uint32_t *)ETHLITE_MDIORD;

    // Read PHY ID register (register 2)
    *mdio_addr = (0 << 5) | 2;  // PHY addr 0, reg 2
    *mdio_ctrl = 0x08 | 0x02;   // Enable + Read operation

    // Wait for operation complete
    while (*mdio_ctrl & 0x01);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ethernet Controller Validation - Part 2}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
    uint32_t phy_id = *mdio_rd;

    uartlite_puts("PHY ID: 0x");
    // Simple hex output (simplified)
    for (int i = 28; i >= 0; i -= 4) {
        uint8_t nibble = (phy_id >> i) & 0xF;
        uartlite_putc(nibble < 10 ? '0' + nibble : 'A' + nibble - 10);
    }
    uartlite_puts("\n");

    return (phy_id != 0x0000 && phy_id != 0xFFFF);
}

int run_ethernet_validation_suite(void) {
    uartlite_puts("Starting Ethernet validation...\n");

    ethernet_validation_init();
    int phy_test = validate_phy_registers();

    uartlite_puts("Ethernet validation: ");
    uartlite_puts(phy_test ? "PASS" : "FAIL");
    uartlite_puts("\n");

    return phy_test;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{XPS Timer-Based Precision Testing - Part 1}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include "peripherals.h"

// MicroBlaze-V XPS Timer registers
#define TIMER_BASE       0x41C00000
#define TIMER_TCSR0      (TIMER_BASE + 0x00)
#define TIMER_TLR0       (TIMER_BASE + 0x04)
#define TIMER_TCR0       (TIMER_BASE + 0x08)

// Timer control bits
#define TIMER_CSR_ENABLE_TMR    0x00000080
#define TIMER_CSR_ENABLE_INT    0x00000040
#define TIMER_CSR_LOAD_TMR      0x00000020
#define TIMER_CSR_AUTO_RELOAD   0x00000010
#define TIMER_CSR_DOWN_COUNT    0x00000002

// Measure execution time of a function (assuming 100MHz clock)
uint32_t measure_execution_cycles(void (*test_function)(void)) {
    volatile uint32_t *tcsr = (volatile uint32_t *)TIMER_TCSR0;
    volatile uint32_t *tlr = (volatile uint32_t *)TIMER_TLR0;
    volatile uint32_t *tcr = (volatile uint32_t *)TIMER_TCR0;

    // Configure timer for maximum count (down counter)
    *tlr = 0xFFFFFFFF;
    *tcsr = TIMER_CSR_ENABLE_TMR | TIMER_CSR_LOAD_TMR | TIMER_CSR_DOWN_COUNT;

    uint32_t start_count = *tcr;
    test_function();
    uint32_t end_count = *tcr;

    return start_count - end_count;  // Cycles elapsed
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{XPS Timer-Based Precision Testing - Part 2}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
int validate_timing_constraint(void (*func)(void), uint32_t max_cycles) {
    uint32_t execution_cycles = measure_execution_cycles(func);

    uartlite_puts("Execution cycles: ");
    // Simple decimal output (simplified)
    uartlite_puts(" (max: ");
    uartlite_puts(")\n");

    if (execution_cycles <= max_cycles) {
        uartlite_puts("PASS\n");
        return 1;
    } else {
        uartlite_puts("FAIL - Too slow!\n");
        return 0;
    }
}

void sample_validation_function(void) {
    // Simulate validation work
    for (volatile int i = 0; i < 1000; i++) {
        volatile int dummy = i * i;  // Prevent optimization
    }
}

int run_timing_validation(void) {
    uartlite_puts("Testing timing constraints...\n");
    // Validate function executes within 100,000 cycles (1ms @ 100MHz)
    return validate_timing_constraint(sample_validation_function, 100000);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interrupt-Based Event Detection - Part 1}
\begin{lstlisting}[language=C, basicstyle=\fontsize{4}{2}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include <stdbool.h>
#include "peripherals.h"

// MicroBlaze-V Interrupt Controller registers
#define INTC_BASE        0x41200000
#define INTC_ISR         (INTC_BASE + 0x00)  // Interrupt Status Register
#define INTC_IPR         (INTC_BASE + 0x04)  // Interrupt Pending Register
#define INTC_IER         (INTC_BASE + 0x08)  // Interrupt Enable Register
#define INTC_IAR         (INTC_BASE + 0x0C)  // Interrupt Acknowledge Register
#define INTC_SIE         (INTC_BASE + 0x10)  // Set Interrupt Enable
#define INTC_CIE         (INTC_BASE + 0x14)  // Clear Interrupt Enable
#define INTC_MER         (INTC_BASE + 0x1C)  // Master Enable Register

#define TIMER_INT_ID     0  // Timer interrupt ID
#define GPIO_INT_ID      1  // GPIO interrupt ID

volatile bool fault_detected = false;
volatile uint32_t fault_count = 0;

// MicroBlaze-V interrupt handler
void interrupt_handler(void) __attribute__((interrupt));

void interrupt_handler(void) {
    volatile uint32_t *isr = (volatile uint32_t *)INTC_ISR;
    volatile uint32_t *iar = (volatile uint32_t *)INTC_IAR;

    uint32_t interrupt_status = *isr;

    if (interrupt_status & (1 << GPIO_INT_ID)) {
        fault_detected = true;
        fault_count++;
        uartlite_puts("FAULT DETECTED!\n");
        *iar = (1 << GPIO_INT_ID);  // Acknowledge interrupt
    }

    if (interrupt_status & (1 << TIMER_INT_ID)) {
        // Handle timer interrupt
        uartlite_puts("Timer interrupt\n");
        *iar = (1 << TIMER_INT_ID);  // Acknowledge interrupt
    }
}

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interrupt-Based Event Detection - Part 2}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{2}\selectfont\ttfamily, backgroundcolor={}]
void setup_interrupt_controller(void) {
    volatile uint32_t *mer = (volatile uint32_t *)INTC_MER;
    volatile uint32_t *ier = (volatile uint32_t *)INTC_IER;

    // Enable master interrupt and hardware interrupt enable
    *mer = 0x03;  // ME = 1, HIE = 1

    // Enable specific interrupts
    *ier = (1 << GPIO_INT_ID) | (1 << TIMER_INT_ID);
}

int run_fault_detection_test(void) {
    uartlite_puts("Starting fault detection test...\n");

    setup_interrupt_controller();
    fault_detected = false;
    fault_count = 0;

    // Enable global interrupts (RISC-V)
    asm volatile ("csrsi mstatus, 0x8");  // Set MIE bit

    // Run test loop
    for (int i = 0; i < 100; i++) {
        if (fault_detected) {
            uartlite_puts("Fault handling in progress...\n");
            fault_detected = false;  // Reset flag
        }
        // Simple delay
        for (volatile int j = 0; j < 1000000; j++);
    }

    uartlite_puts("Fault detection test complete\n");
    return 1;
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Hardware-in-the-Loop Testing Concepts}
\begin{center}
\textbf{Hardware-in-the-Loop Test Setup}
\end{center}

\begin{columns}
\begin{column}{0.5\textwidth}
\textbf{Test System:}
\begin{itemize}
    \item MicroBlaze-V Controller
    \item Control Signals
    \item Data Acquisition
    \item Automated Testing
\end{itemize}
\end{column}
\begin{column}{0.5\textwidth}
\textbf{External Equipment:}
\begin{itemize}
    \item Power Supply
    \item Oscilloscope
    \item Logic Analyzer
    \item Device Under Test
\end{itemize}
\end{column}
\end{columns}

\vspace{0.5cm}
\textbf{HIL Testing Benefits:}
\begin{itemize}
    \item \textbf{Real conditions:} Actual hardware behavior
    \item \textbf{Automated testing:} Repeatable test sequences
    \item \textbf{Fault injection:} Controlled error conditions
    \item \textbf{Regression testing:} Verify fixes don't break other features
    \item \textbf{Stress testing:} Push hardware to limits
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Fault Injection Implementation}
\begin{lstlisting}[language=C, basicstyle=\fontsize{4}{2}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include <stdbool.h>
#include "peripherals.h"

// MicroBlaze-V fault injection control pins
#define POWER_CONTROL_MASK 0x10
#define CLOCK_CONTROL_MASK 0x20
#define RESET_CONTROL_MASK 0x40

typedef enum {
    FAULT_NONE,
    FAULT_POWER_GLITCH,
    FAULT_CLOCK_GLITCH,
    FAULT_RESET_PULSE,
    FAULT_REGISTER_CORRUPTION
} fault_type_t;

void inject_power_glitch(uint32_t duration_cycles) {
    volatile uint32_t *gpio_data = (volatile uint32_t *)GPIO_DATA_REG;

    uartlite_puts("Injecting power glitch\n");
    *gpio_data &= ~POWER_CONTROL_MASK;  // Cut power signal

    // Delay using cycle counting
    for (volatile uint32_t i = 0; i < duration_cycles; i++);

    *gpio_data |= POWER_CONTROL_MASK;   // Restore power signal

    // Allow system to stabilize
    for (volatile uint32_t i = 0; i < 1000000; i++);
}

void inject_register_corruption(void) {
    volatile uint32_t *test_reg = (volatile uint32_t *)0x80000000;  // DDR test area

    uartlite_puts("Injecting register corruption\n");

    // Corrupt memory pattern
    for (int i = 0; i < 16; i++) {
        test_reg[i] = 0xDEADBEEF ^ i;  // Corrupt with pattern
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Real-Time Debugging Strategies}
\textbf{Challenges in real-time systems:}
\begin{itemize}
    \item Timing-sensitive operations
    \item Interrupt-driven behavior
    \item Race conditions
    \item Resource contention
    \item Non-deterministic execution
\end{itemize}

\vspace{0.5cm}
\textbf{Debugging techniques:}
\begin{itemize}
    \item \textbf{Non-intrusive logging:} Minimal impact on timing
    \item \textbf{State machines:} Track system states
    \item \textbf{Watchdog timers:} Detect system hangs
    \item \textbf{Performance counters:} Monitor resource usage
    \item \textbf{Logic analyzers:} Capture signal timing
\end{itemize}

\vspace{0.5cm}
\textbf{Best practices:}
\begin{itemize}
    \item Keep interrupt handlers short
    \item Use atomic operations for shared data
    \item Implement proper synchronization
    \item Test under worst-case conditions
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Performance Optimization Example - Part 1}
\begin{lstlisting}[language=C, basicstyle=\fontsize{6}{6}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include "peripherals.h"

// Unoptimized version
int validate_registers_slow(uint32_t *registers, int count) {
    int errors = 0;
    for (int i = 0; i < count; i++) {
        uint32_t expected = calculate_expected_value(i);  // Expensive!
        if (registers[i] != expected) {
            errors++;
            uartlite_puts("Register error at index ");
            // Simple decimal output (simplified)
            uartlite_puts("\n");
        }
    }
    return errors;
}

// Optimized version
int validate_registers_fast(uint32_t *registers, int count) {
    static uint32_t expected_values[MAX_REGISTERS];  // Pre-calculated
    static bool values_initialized = false;

    // Initialize expected values once
    if (!values_initialized) {
        for (int i = 0; i < count; i++) {
            expected_values[i] = calculate_expected_value(i);
        }
        values_initialized = true;
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Performance Optimization Example - Part 2}
\begin{lstlisting}[language=C, basicstyle=\fontsize{6}{6}\selectfont\ttfamily, backgroundcolor={}]
    int errors = 0;
    for (int i = 0; i < count; i++) {
        if (registers[i] != expected_values[i]) {
            errors++;
            // Minimal logging for speed
            error_log[errors-1] = i;  // Just store index
        }
    }
    return errors;
}

void benchmark_validation_functions(void) {
    uint32_t test_registers[100];
    // Initialize test data...

    uint32_t slow_cycles = measure_execution_cycles(
        validate_registers_slow_wrapper);
    uint32_t fast_cycles = measure_execution_cycles(
        validate_registers_fast_wrapper);

    uartlite_puts("Slow version cycles: ");
    uartlite_puts("\n");
    uartlite_puts("Fast version cycles: ");
    uartlite_puts("\n");
    uartlite_puts("Performance improvement achieved\n");
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Interactive Poll: Debugging Challenge}
\begin{center}
\Large Your validation system occasionally hangs. What's your first debugging step?
\end{center}

\textbf{A)} Add more printf statements everywhere

\textbf{B)} Implement a watchdog timer

\textbf{C)} Use a logic analyzer to check signals

\textbf{D)} Rewrite the entire system

\pause

\begin{alertblock}{Answer}
\textbf{B)} Watchdog timer - Detect and recover from hangs automatically!
\end{alertblock}

\vspace{0.5cm}
\textbf{Then} use logic analyzer and targeted debugging to find root cause.
\end{frame}

\begin{frame}[fragile]
\frametitle{Timer-Based System Monitoring - Part 1}
\begin{lstlisting}[language=C, basicstyle=\fontsize{6}{6}\selectfont\ttfamily, backgroundcolor={}]
#include <stdint.h>
#include <stdbool.h>
#include "peripherals.h"

#define SYSTEM_TIMEOUT_CYCLES 500000000  // 5 seconds @ 100MHz

volatile bool system_alive = true;
volatile uint32_t heartbeat_counter = 0;

void setup_system_monitor(void) {
    volatile uint32_t *tcsr = (volatile uint32_t *)TIMER_TCSR0;
    volatile uint32_t *tlr = (volatile uint32_t *)TIMER_TLR0;

    // Configure timer for system monitoring
    *tlr = SYSTEM_TIMEOUT_CYCLES;
    *tcsr = TIMER_CSR_ENABLE_TMR | TIMER_CSR_ENABLE_INT | TIMER_CSR_AUTO_RELOAD;

    uartlite_puts("System monitor enabled\n");
}

void system_heartbeat(void) {
    // Reset timer to prevent timeout
    volatile uint32_t *tcsr = (volatile uint32_t *)TIMER_TCSR0;
    *tcsr |= TIMER_CSR_LOAD_TMR;  // Reload timer

    heartbeat_counter++;
    system_alive = true;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Timer-Based System Monitoring - Part 2}
\begin{lstlisting}[language=C, basicstyle=\fontsize{5}{5}\selectfont\ttfamily, backgroundcolor={}]
void validation_main_loop(void) {
    setup_system_monitor();

    while (1) {
        system_heartbeat();  // Reset monitor at start of each cycle

        uartlite_puts("Starting validation cycle...\n");

        // Run validation tests
        int gpio_result = run_gpio_tests();
        system_heartbeat();  // Reset after each major operation

        int ethernet_result = run_ethernet_tests();
        system_heartbeat();

        int timing_result = run_timing_tests();
        system_heartbeat();

        // Report results
        uartlite_puts("Cycle complete\n");

        // Simple delay
        for (volatile int i = 0; i < 10000000; i++);
    }
}

// Timer interrupt handler for system monitoring
void timer_timeout_handler(void) {
    if (!system_alive) {
        uartlite_puts("SYSTEM HANG DETECTED! Initiating recovery...\n");
        // Implement recovery procedure
        system_reset();
    }
    system_alive = false;  // Will be set true by heartbeat
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Lab Preview: Complete Hardware Validator}
\textbf{This afternoon you'll build:}
\begin{itemize}
    \item \footnotesize Comprehensive MicroBlaze-V peripheral validation suite
    \item \footnotesize Advanced debugging with printf and LED indicators
    \item \footnotesize Hardware-in-the-loop testing framework
    \item \footnotesize Fault injection and recovery testing
    \item \footnotesize Performance-optimized validation routines
    \item \footnotesize Real-time constraint validation
\end{itemize}

\vspace{0.2cm}
\textbf{Advanced features:}
\begin{itemize}
    \item \footnotesize Interrupt-based event handling
    \item \footnotesize Watchdog protection system
    \item \footnotesize Automated test reporting
    \item \footnotesize Statistical analysis of results
    \item \footnotesize AI-assisted optimization
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Hardware Safety Considerations}
\textbf{Protecting your hardware:}
\begin{itemize}
    \item \footnotesize \textbf{Voltage limits:} Never exceed 3.3V on MicroBlaze-V pins
    \item \footnotesize \textbf{Current limits:} Maximum 12mA per GPIO pin
    \item \footnotesize \textbf{ESD protection:} Use anti-static precautions
    \item \footnotesize \textbf{Power sequencing:} Proper startup/shutdown procedures
    \item \footnotesize \textbf{Thermal management:} Monitor temperature during stress tests
\end{itemize}

\vspace{0.2cm}
\textbf{Validation safety practices:}
\begin{itemize}
    \item \footnotesize Start with low-stress tests
    \item \footnotesize Implement emergency shutdown procedures
    \item \footnotesize Use current-limited power supplies
    \item \footnotesize Monitor system health continuously
    \item \footnotesize Have backup hardware available
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Key Takeaways - Day 5}
\begin{itemize}
    \item \footnotesize \textbf{Hardware debugging is different:} Use printf, LEDs, and external tools
    \item \footnotesize \textbf{Peripherals enable validation:} GPIO, ADC, timers are your tools
    \item \footnotesize \textbf{Real-time matters:} Timing constraints are critical
    \item \footnotesize \textbf{Fault injection tests robustness:} Controlled failures reveal weaknesses
    \item \footnotesize \textbf{Optimization is essential:} Embedded systems demand efficiency
    \item \footnotesize \textbf{Safety first:} Protect hardware during aggressive testing
\end{itemize}

\vspace{0.5cm}
\begin{center}
\textbf{You're now a hardware validation expert!}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Tonight's Homework}
\textbf{Enhance your hardware validator:}
\begin{enumerate}
    \item \footnotesize Add comprehensive peripheral testing
    \item \footnotesize Implement fault injection scenarios
    \item \footnotesize Optimize critical validation routines
    \item \footnotesize Add watchdog protection and error recovery
    \item \footnotesize Create detailed performance benchmarks
    \item \footnotesize Use AI to suggest hardware-specific optimizations
\end{enumerate}

\vspace{0.5cm}
\textbf{Advanced challenges:}
\begin{itemize}
    \item \footnotesize Implement interrupt-based testing
    \item \footnotesize Add statistical analysis of test results
    \item \footnotesize Create automated test report generation
    \item \footnotesize Explore advanced MicroBlaze-V features (PIO, DMA)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Tomorrow Preview: Capstone Project}
\begin{center}
\Large The Grand Finale!
\end{center}

\textbf{Day 6 - Capstone Project:}
\begin{itemize}
    \item Integrate all learned concepts
    \item Design and implement complete validation system
    \item Team collaboration and project management
    \item Professional presentation of results
    \item Portfolio development and career planning
    \item Course wrap-up and next steps
\end{itemize}

\vspace{0.5cm}
\begin{alertblock}{Showcase Day}
Tomorrow you'll demonstrate your validation engineering skills!
\end{alertblock}
\end{frame}

\begin{frame}
\frametitle{Questions \& Discussion}
\begin{center}
\Large Ready to validate real hardware?
\end{center}

\begin{itemize}
    \item Hardware debugging techniques questions?
    \item MicroBlaze-V peripheral programming challenges?
    \item Real-time optimization strategies?
    \item Fault injection implementation ideas?
    \item Excited about tomorrow's capstone project?
\end{itemize}

\vspace{1cm}
\begin{center}
\textbf{Time to build your hardware validation masterpiece!}
\end{center}
\end{frame}

\end{document}

